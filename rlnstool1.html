<HTML><HEAD><TITLE>Using RLNSTOOL</TITLE>
<BODY>
<H1>Using RLNSTOOL</H1>
<HR>
<P>RLNSTOOL generates several Verilog files that correspond to the information specified in <tt> rlnstool.h </tt>. 
A first set of files contains synthesizable Verilog modules for basic RLNS operations using binary-encoded moduli:
<DL>
  <DT> <tt>add2rlns.v</tt> defines <tt> add_residueLNS(s2,a2,b2);</tt> 
  <DD> Add inputs <tt> a2 </tt> and <tt> b2 </tt> producing the output <tt> s2 </tt> using the improved algorithm described in the <a href="rlns.pdf"> paper </a>.
  <DT> <tt>nad2rlns.v</tt> defines an alternative for <tt> add_1hot_residueLNS(s2,a2,b2);</tt>
  <DD> Add inputs <tt> a2 </tt> and <tt> b2 </tt> producing the output <tt> s2 </tt> using a naive algorithm.
  <DT> <tt>alt2rlns.v</tt> defines yet another alternative for <tt> add_1hot_residueLNS(s2,a2,b2);</tt> 
  <DD> Add inputs <tt> a2 </tt> and <tt> b2 </tt> producing the output <tt> s2 </tt> using an alternative Verilog coding for the naive algorithm.
  <DT> <tt>mul2rlns.v</tt> defines <tt> mul_residueLNS(p2,a2,b2);</tt>
  <DD> Multiply inputs <tt> a2 </tt> and <tt> b2 </tt> producing the output <tt> p2</tt>.
  <DT> <tt>div2rlns.v</tt> defines <tt> div_residueLNS(q2,a2,b2);</tt>
  <DD> Divide inputs <tt> a2 </tt> and <tt> b2 </tt> producing the output <tt> q2</tt>.
</DD></DL>
The bitwidth of the binary-encoded RLNS variables (<tt> a2, b2, ... </tt>) will be 1 (for the value sign) plus the sum of the bit widths of each of the moduli.
For example, the moduli 4, 3, 5 and 7 used in the <a href="rlns.pdf"> paper </a> require 11 bits.  Each file will have a macro defined to avoid mixing incompatible files.  
For the example moduli, this macro must be <tt> `MODULI_4_3_5_7 </TT> in every binary-encoded-moduli file.

<P>
Another similar set of files that contain synthesizable Verilog modules for one-hot-encoded moduli:
<DL>
  <DT> <tt>add1rlns.v</tt> defines <tt> add_1hot_residueLNS(s1,a1,b1);</tt> 
  <DD> Add inputs <tt> a1 </tt> and <tt> b1 </tt> producing the output <tt> s1 </tt> using the improved algorithm described in the <a href="rlns.pdf"> paper </a>.
  <DT> <tt>nad1rlns.v</tt> defines an alternative for <tt> add_1hot_residueLNS(s2,a2,b2);</tt>
  <DD> Add inputs <tt> a1 </tt> and <tt> b1 </tt> producing the output <tt> s1 </tt> using a naive algorithm.
  <DT> <tt>alt1rlns.v</tt> defines yet another alternative for <tt> add_1hot_residueLNS(s2,a2,b2);</tt> 
  <DD> Add inputs <tt> a1 </tt> and <tt> b1 </tt> producing the output <tt> s1 </tt> using an alternative Verilog coding for the naive algorithm.
  <DT> <tt>mul1rlns.v</tt> defines <tt> mul_1hot_residueLNS(p1,a1,b1);</tt>
  <DD> Multiply inputs <tt> a1 </tt> and <tt> b1 </tt> producing the output <tt> p1</tt>.
  <DT> <tt>div1rlns.v</tt> defines <tt> div_1hot_residueLNS(q1,a1,b1);</tt>
  <DD> Divide inputs <tt> a1 </tt> and <tt> b1 </tt> producing the output <tt> q1</tt>.
</DD></DL>
The bitwidth of the one-hot-encoded RLNS variables (<tt> a1, b1, ... </tt>) will be 1 (for the value sign) plus the sum of each of the moduli.
For example, the moduli 4, 3, 5 and 7 used in the <a href="rlns.pdf"> paper </a> require 20 bits.  Each file will have a macro defined 
to avoid mixing incompatible files.  
For the example moduli, this macro must be <tt> `MODULI_ONEHOT_4_3_5_7 </TT> in every one-hot-encoded-moduli file.

<P>
Because of the underlying limitations of residue integers, RLNS cannot detect underflow and overflow on the fly, the way conventional LNS and floating point can.
To assist in finding bugs that result from this, an optional macro may be defined that allows simulation-time 
testing of the result of the above modules.  (This macro should not be defined during synthesis).  This macro is 
<tt> `CHECK_RELERR</tt>, which should be defined to be a real number greater than the relative error inherent in the choice of the moduli, BASE and ZSCALE.
When errors greater than this occur (probably due to overflow or underflow), an error messsage is printed, allowing the designer to 
identify the cause, and correct the problem either by making appropriate changes to the algorithm to avoid the overflow, 
or by increasing the dynamic range of the RLNS (using larger moduli or a bigger BASE or a smaller ZSCALE).

<P>
Since the RLNS variables have three levels of abstraction (logarithm, residue and moduli), some routines are generated by RLNSTOOL for simulation-time
printing and conversion of RLNS values:
<DL>
  <DT> <tt>cvt1rlns.v</tt> defines the function <tt> cvt_1hot_residueLNS(a1);</tt> 
  <DD> Convert one-hot-encoded-moduli <tt> a1 </tt> into a Verilog real.
  <DT> <tt>pri1rlns.v</tt> defines the function <tt> print_1hot_residueLNS(a1);</tt> 
  <DD> Print one-hot-encoded-moduli <tt> a1 </tt> as its value sign and RNS logarithm as well as the associated real.
  <DT> <tt>cvt2rlns.v</tt> defines the function <tt> cvt_residueLNS(a1);</tt> 
  <DD> Convert binary-encoded-moduli <tt> a2 </tt> into a Verilog real.
  <DT> <tt>pri2rlns.v</tt> defines the function <tt> print_residueLNS(a1);</tt> 
  <DD> Print binary-encoded-moduli <tt> a2 </tt> as its value sign and RNS logarithm as well as the associated real.
</DD></DL>

 
</BODY></HTML>
